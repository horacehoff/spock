use std::str::FromStr;
use crate::{Expr, Opcode};


grammar;

pub Expression: Expr = {
    <o:Operation> => o,
    <t: Term> => *t,
}

pub Operation: Expr = {
    <o1: Term> <o3: (<Op> <Term>)+> => {
        Expr::Op(o1, o3.into_boxed_slice())
    }
}

pub Term: Box<Expr> = {
    <t: Num> => Box::new(Expr::Num(t)),
    <b: Bool> => Box::new(Expr::Bool(b)),
    <s: String> => Box::new(Expr::String(s)),
    "(" <o2: Term> ")" => Box::new(Expr::Priority(o2)),
};

Num: f64 = {
    <n: r"[+-]?([0-9]*[.])?[0-9]+"> => f64::from_str(n).unwrap()
};

Bool: bool = {
    <b: r"true|false"> => bool::from_str(b).unwrap()
};

String: String = {
    <s: r#"\"(?:\"\"|[^\"])*\""#> => String::from(s.trim_matches('"'))
}

Op: Opcode = {
    "*" => Opcode::Mul,
    "+" => Opcode::Add,
    "/" => Opcode::Div,
    "-" => Opcode::Sub,
    "%" => Opcode::Mod,
    "==" => Opcode::Eq,
    "!="  =>  Opcode::NotEq,
    ">"  =>  Opcode::Sup,
     ">="  => Opcode::SupEq,
     "<" =>   Opcode::Inf,
     "<="  => Opcode::InfEq,
     "&&"  => Opcode::BoolAnd,
     "||"  => Opcode::BoolOr,
}