use std::str::FromStr;
use crate::Opcode;
use crate::parser::Expr;
use crate::display::format_parser_error;
use inline_colorization::*;
use crate::error_b;
use crate::Num;
use crate::is_float;
use internment::Intern;
use crate::ops::remove_priority;
use crate::ops::op_to_rpn;
use crate::display::format_parser_error_recovery;
use concat_string::concat_string;
use crate::display::format_expr_type;


grammar;


pub File:Vec<Expr> = {
    <o: Function*> => o,
}

pub Function:Expr = {
    "fn" <o1: r#"([a-zA-Z_]*)\("#> <o2: (Var ("," Var)*)?>  ")" "{" <o3:Code> "}" => {
        let mut final_args:Vec<String> = vec![o1.to_string()];
        if let Some(fn_args) = o2 {
            let args = fn_args;
            final_args.push(args.0);
            if !args.1.is_empty() {
                final_args.extend(args.1.iter().map(|(_,b)|b.clone()).collect::<Vec<String>>())
            }
        }
        return Expr::FunctionDecl(final_args.into_boxed_slice(), o3);
    },
    "fn" <o1:Var> "(" <o2: (Var ("," Var)*)?>  ")" "{" <o3:Code> "}" => {
            let mut final_args:Vec<String> = vec![o1.to_string()];
            if let Some(fn_args) = o2 {
                let args = fn_args;
                final_args.push(args.0);
                if !args.1.is_empty() {
                    final_args.extend(args.1.iter().map(|(_,b)|b.clone()).collect::<Vec<String>>())
                }
            }
            return Expr::FunctionDecl(final_args.into_boxed_slice(), o3);
        },
    ! => {
        error_b!(format_parser_error_recovery(<>, "FUNCTION"));
    }

}

ElseIfBlock:Expr = {
    "else" "if" <o1: Expression> "{" <o2:Code> "}" => Expr::ElseIfBlock(Box::from(o1), o2)
}

ElseBlock:Expr = {
    "else" "{" <o2:Code> "}" => Expr::ElseBlock(o2)
}

ConditionalBlock: Expr = {
    "if" <o1: Expression> "{" <o2:Code> "}" <o3: ElseIfBlock*> <o4: ElseBlock?> => {
        let mut code = o2.to_vec();
        for x in o3 {
            code.push(x);
        }
        if let Some(x) = o4 {
            code.push(x);
        }
        Expr::Condition(Box::from(o1), code.into_boxed_slice())
    }
}

WhileBlock: Expr = {
    "while" <o1: Expression> "{" <o2:Code> "}" => Expr::WhileBlock(Box::from(o1), o2)
}

ForLoop:Expr = {
    "for" <o1:Var> "in" <o2: Expression> "{" <o3:Code> "}" => {
        let mut output = vec![o2];
        output.extend(o3);
        Expr::ForLoop(Intern::from(o1),output.into_boxed_slice())
    }
}

pub Code: Box<[Expr]> = {
    <s: Statement*> => s.into_boxed_slice()
}

pub Import:Expr = {
    <path: r"import [a-zA-Z_.\/-]*"> => {
        Expr::Import(String::from(path.trim_start_matches("import").trim()))
    },
    ! => {
        error_b!(format_parser_error_recovery(<>, "IMPORT STATEMENT"));
    }
}

Statement: Expr = {
    ConditionalBlock => <>,
    WhileBlock => <>,
    ForLoop => <>,
    Function => <>,
    Line => <>
}

Line: Expr = {
    <a: VarDeclare> ";" => a,
    <a: VarAssign> ";" => a,
    <a: OpVarAssign> ";" => a,
    <a: ReturnLn> ";" => a,
    <a: Expression> ";" => a,
}

ReturnLn: Expr = {
    "return" <e: Expression?> => Expr::ReturnVal(Box::new(e))
}

VarDeclare: Expr = {
    "let" <v: Var> "=" <e: Expression> => Expr::VarDeclare(Intern::from(v), Box::from(e)),
}

VarAssign: Expr = {
    <v: Var> "=" <e: Expression> => Expr::VarAssign(Intern::from(v), Box::from(e)),
    <i: IndexAccess> "=" <e: Expression> => {
        if let Expr::GetIndex(a,b) = i {
            Expr::ArrayModify(a,b,Box::new(e))
        } else {
          unreachable!()
        }
    },
    ! => {
        error_b!(format_parser_error_recovery(<>, "VARIABLE ASSIGNMENT"));
    }
}

OpVarAssign: Expr = {
    <v: Var> "+=" <e: Expression> => Expr::VarAssign(Intern::from_ref(&v), Box::from(Expr::Op(Box::from([Expr::Var(Intern::from(v)),e, Expr::Opcode(Opcode::Add)])))),
    <v: Var> "-=" <e: Expression> => Expr::VarAssign(Intern::from_ref(&v), Box::from(Expr::Op(Box::from([Expr::Var(Intern::from(v)),e, Expr::Opcode(Opcode::Sub)])))),
    <v: Var> "*=" <e: Expression> => Expr::VarAssign(Intern::from_ref(&v), Box::from(Expr::Op(Box::from([Expr::Var(Intern::from(v)),e,Expr::Opcode(Opcode::Mul)])))),
    <v: Var> "/=" <e: Expression> => Expr::VarAssign(Intern::from_ref(&v), Box::from(Expr::Op(Box::from([Expr::Var(Intern::from(v)),e,Expr::Opcode(Opcode::Div)])))),
    <v: Var> "%=" <e: Expression> => Expr::VarAssign(Intern::from_ref(&v), Box::from(Expr::Op(Box::from([Expr::Var(Intern::from(v)),e,Expr::Opcode(Opcode::Mod)])))),
    <v: Var> "^=" <e: Expression> => Expr::VarAssign(Intern::from_ref(&v), Box::from(Expr::Op(Box::from([Expr::Var(Intern::from(v)),e,Expr::Opcode(Opcode::Pow)])))),
}

IndexAccess: Expr = {
    <t: Term> <f: ("[" Expression "]")+> => {
        Expr::GetIndex(Box::from(t), f.iter().map(|x| x.1.clone()).collect::<Vec<Expr>>().into_boxed_slice())
    }
}

Expression: Expr = {
    <o:Operation> => o,
    <t: Term> => t,
    <i: IndexAccess> => i,
}

Operation: Expr = {
    "-" <t: Term> => {
        if let Expr::Num(x) = t {
            return Expr::Num(-x);
        }
        return Expr::Op(Box::from([Expr::Num(0.0 as Num), Expr::Opcode(Opcode::Neg), t]));
    },
    <o1: Term> <o3: (<Op> <Term>)+> => {
        let mut output_op:Vec<Expr> = vec![o1];
        for x in o3 {
            output_op.push(Expr::Opcode(x.0));
            output_op.extend(remove_priority(x.1));
        }
        output_op = op_to_rpn(output_op);


        // constant folding
        if output_op.iter().any(|x| !matches!(x, Expr::Num(_) | Expr::Bool(_) | Expr::String(_) | Expr::Opcode(_))) {
            Expr::Op(output_op.into_boxed_slice())
        } else {
            let mut output_num:Expr = Expr::Num(0.0 as Num);
            let mut stack:Vec<Expr> = Vec::new();
            for x in output_op {
                if let Expr::Opcode(op) = x {
                    let last = stack.pop().unwrap();
                    let first = {
                        if let Some(num) = stack.pop() {
                            num
                        } else {
                            output_num
                        }
                    };
                    output_num = match op {
                        Opcode::Add => {
                            match (first,last) {
                            (Expr::Num(x),Expr::Num(y)) => Expr::Num(x+y),
                            (Expr::String(x),Expr::String(y)) => Expr::String(concat_string!(x,y)),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} + {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        },
                        Opcode::Mul => {
                            match (first,last) {
                            (Expr::Num(x),Expr::Num(y)) => Expr::Num(x*y),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} * {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        },
                        Opcode::Div => {
                            match (first,last) {
                            (Expr::Num(x),Expr::Num(y)) => Expr::Num(x/y),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} / {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        },
                        Opcode::Sub => {
                            match (first,last) {
                            (Expr::Num(x),Expr::Num(y)) => Expr::Num(x-y),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} - {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        },
                        Opcode::Mod => {
                            match (first,last) {
                            (Expr::Num(x),Expr::Num(y)) => Expr::Num(x%y),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} % {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        },
                        Opcode::Pow => {
                            match (first,last) {
                            (Expr::Num(x),Expr::Num(y)) => Expr::Num(is_float!(x.powf(y),x.pow(y as u32))),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} ^ {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        },
                        Opcode::Eq => {
                            Expr::Bool(first == last)
                        },
                        Opcode::NotEq => {
                            Expr::Bool(first != last)
                        },
                        Opcode::Sup => {
                            match (first,last) {
                            (Expr::Num(x),Expr::Num(y)) => Expr::Bool(x > y),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} > {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        },
                        Opcode::SupEq => {
                            match (first,last) {
                            (Expr::Num(x),Expr::Num(y)) => Expr::Bool(x >= y),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} >= {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        },
                        Opcode::Inf => {
                            match (first,last) {
                            (Expr::Num(x),Expr::Num(y)) => Expr::Bool(x < y),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} < {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        },
                        Opcode::InfEq => {
                            match (first,last) {
                            (Expr::Num(x),Expr::Num(y)) => Expr::Bool(x <= y),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} <= {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        },
                        Opcode::BoolAnd => {
                            match (first,last) {
                            (Expr::Bool(x),Expr::Bool(y)) => Expr::Bool(x && y),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} && {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        },
                        Opcode::BoolOr => {
                            match (first,last) {
                            (Expr::Bool(x),Expr::Bool(y)) => Expr::Bool(x || y),
                            (x,y) => {error_b!(format_args!(
                                  "UNSUPPORTED OPERATION: {} || {}",
                                  format_expr_type(x),
                                  format_expr_type(y)
                              ));}
                            }
                        }
                        _ => unreachable!()
                        }
                } else {
                    stack.push(x);
                }
            }
            output_num
        }
    }
}

Term: Expr = {
    "(" <o2: Expression> ")" => Expr::Priority(Box::new(o2)),
    <t: Num> => Expr::Num(t),
    <b: Bool> => Expr::Bool(b),
    <s: String> => Expr::String(s),
    <v: Var> => Expr::Var(Intern::from(v)),
    "[" <t: Expression?> <f: ("," Expression)*> "]" => {
        let mut terms = Vec::new();
        if let Some(x) = t {
            terms.push(x);
        }
        terms.extend(f.iter().map(|x| x.1.clone()).collect::<Vec<_>>());
        Expr::Array(terms.into_boxed_slice())
    },
    <f: FunctionCall> => <>,
    <o: ObjFunctionCall> => <>,
};

FunctionCall: Expr = {
    <namespace: (Var "::")+?> <o1: r#"([a-zA-Z_]*)\("#> <o2: Expression?> <o3: ("," Expression)+?> ")" => {
        let mut args:Vec<Expr> = Vec::new();
        if let Some(arg) = o2 {
            args.push(arg);
        }
        if let Some(add_args) = o3 {
            args.extend(add_args.iter().map(|(_, x)|x.clone()));
        }
        Expr::FunctionCall(args.into_boxed_slice(), {
            if let Some(ns) = namespace {
                let mut ns = ns.iter().map(|x| x.0.to_string()).collect::<Vec<String>>();
                ns.push(String::from(o1.trim_end_matches('(')));
                ns.into_boxed_slice()
            } else {
                Box::from(vec![String::from(o1.trim_end_matches('('))])
            }
        })
    }
}

ObjFunctionCall:Expr = {
    <t: Term> <o1: r#"\.([a-zA-Z_]*)\("#> <o2: Expression?> <o3: ("," Expression)+?> ")" <o: ("." FunctionCall)*> => {
        let mut args:Vec<Expr> = Vec::new();
        if let Some(arg) = o2 {
            args.push(arg);
        }
        if let Some(add_args) = o3 {
            args.extend(add_args.iter().map(|(_, x)|x.clone()));
        }
        let mut func_calls = vec![(String::from(o1.trim_end_matches('(').trim_start_matches('.')),args.into_boxed_slice())];
        for x in o.iter().map(|x| x.1.clone()) {
            if let Expr::FunctionCall(y,x) = x {
                func_calls.push((x.last().unwrap().to_string(),y))
            }
        }
        Expr::ObjFunctionCall(Box::from(t), Box::from(func_calls))
    }
}

Num: Num = {
    <n: r"([0-9]*[.])?[0-9]+"> => is_float!(f64::from_str(n).unwrap(),isize::from_str(n).unwrap())
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

String: String = {
    <s: r#"\"(?:\"\"|[^\"])*\""#> => String::from(s.trim_matches('"'))
}

Var: String = {
    <v: r#"[a-zA-Z_]*"#> => String::from(v),
}

Op: Opcode = {
    "*" => Opcode::Mul,
    "+" => Opcode::Add,
    "/" => Opcode::Div,
    "-" => Opcode::Sub,
    "%" => Opcode::Mod,
    "^" => Opcode::Pow,
    "==" => Opcode::Eq,
    "!="  =>  Opcode::NotEq,
    ">"  =>  Opcode::Sup,
     ">="  => Opcode::SupEq,
     "<" =>   Opcode::Inf,
     "<="  => Opcode::InfEq,
     "&&"  => Opcode::BoolAnd,
     "||"  => Opcode::BoolOr,
}
