use std::str::FromStr;
use crate::{Expr, Opcode};


grammar;

pub VariableDeclaration: Expr = {
    "let" <v: Var> "=" <e: Expression> => Expr::VariableDeclaration(v, Box::from(e))
}

pub Expression: Expr = {
    <o:Operation> => o,
    <t: Term> => *t,
}

pub Operation: Expr = {
    <o1: Term> <o3: (<Op> <Term>)+> => {
        Expr::Op(o1, o3.into_boxed_slice())
    }
}

pub Term: Box<Expr> = {
    <t: Num> => Box::new(Expr::Num(t)),
    <b: Bool> => Box::new(Expr::Bool(b)),
    <s: String> => Box::new(Expr::String(s)),
    <v: Var> => Box::new(Expr::Var(v)),
    "(" <o2: Term> ")" => Box::new(Expr::Priority(o2)),
};

Num: f64 = {
    <n: r"[+-]?([0-9]*[.])?[0-9]+"> => f64::from_str(n).unwrap()
};

Bool: bool = {
    "true" => true,
    "false" => false,
};

String: String = {
    <s: r#"\"(?:\"\"|[^\"])*\""#> => String::from(s.trim_matches('"'))
}

Var: String = {
    <v: r#"[a-zA-Z_]*"#> => String::from(v),
}

Op: Opcode = {
    "*" => Opcode::Mul,
    "+" => Opcode::Add,
    "/" => Opcode::Div,
    "-" => Opcode::Sub,
    "%" => Opcode::Mod,
    "==" => Opcode::Eq,
    "!="  =>  Opcode::NotEq,
    ">"  =>  Opcode::Sup,
     ">="  => Opcode::SupEq,
     "<" =>   Opcode::Inf,
     "<="  => Opcode::InfEq,
     "&&"  => Opcode::BoolAnd,
     "||"  => Opcode::BoolOr,
}